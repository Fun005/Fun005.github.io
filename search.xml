<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记芒果TV一次不成功的面试（1）-----性能优化]]></title>
    <url>%2F%E9%9D%A2%E8%AF%95%2F2019%2F04%2F15%2F%E8%AE%B0%E8%8A%92%E6%9E%9CTV%E4%B8%80%E6%AC%A1%E4%B8%8D%E6%88%90%E5%8A%9F%E7%9A%84%E9%9D%A2%E8%AF%95%EF%BC%881%EF%BC%89-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[因为朋友内推，运气好有芒果TV的一面机会。但由于一年多没参加面试，自己平时的积累总结又不够，所以回答并不是很完善完整，一面感觉…. 不管怎样，下面针对面试内容，来回顾和总结下相关知识，为接下来的求职面试，做准备吧。 在这次面试中，面试官问到了前端性能优化、跨域、H5、组件编写能力等等，我会分篇记录。 性能优化的目的 从用户角度而言，优化能让页面加载更快、用户操作响应更及时、用户使用体验更好。 从服务器角度而言，优化能减少页面请求数、减少请求所占带宽、能够节省资源。 合理的优化能够改善和提升用户体验，节省资源成本。 前端优化的途径有很多，按粒度大致可以分为两类，第一类是页面级别的优化，例如 HTTP请求数、脚本的无阻塞加载、内联脚本的位置优化等 ;第二类则是代码级别的优化，例如 Javascript中的DOM 操作优化、CSS选择符优化、图片优化以及 HTML结构优化等等。另外，本着提高投入产出比的目的，后文提到的各种优化策略大致按照投入产出比从大到小的顺序排列。 一、页面级优化 减少HTTP请求数这条策略基本上所有前端人都知道，而且也是最重要最有效的。都说要减少 HTTP请求，那请求多了到底会怎么样呢 ?首先，每个请求都是有成本的，既包含时间成本也包含资源成本。一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。时间成本就是用户需要看到或者 “感受” 到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。另外，由于浏览器进行并发请求的请求数是有上限的 (具体参见此处 )，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给用户造成站点速度慢这样一个印象，即使可能用户能看到的第一屏的资源都已经请求完了，但是浏览器的进度条会一直存在。减少HTTP请求数的主要途径包括：（1）设计层面对界面进行简化（2）合理设置HTTP缓存（3）资源压缩与合并（4）CSS Sprites 将加载的内容在页面信息加载后再加载 异步执行页面脚本 Lazy Load Javascript CSS in HEAD 异步请求callback 减少不必要的HTTP跳转 避免重复请求 二、代码级优化 javascript（1）DOMDOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。如果脚本中包含了大量的 DOM操作则需要注意以下几点：a. HTML Collection（HTML收集器，返回的是一个数组内容信息）。在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的 “访问集合” 包括读取集合的 length属性、访问集合中的元素。因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。b. Reflow &amp; Repaint。除了上面一点之外， DOM操作还需要考虑浏览器的 Reflow和Repaint ，因为这些都是需要消耗资源的。（2）慎用with。 使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。 除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。（3）避免使用eval和Function。每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。（4）减少作用域链查找。 如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。 要减少作用域链查找还应该减少闭包的使用。（5）数据访问。 Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量：a. 对任何对象属性的访问超过1次。b. 对任何数组成员的访问次数超过1次。另外要尽可能减少对象和数组的深度查找。（2） CSS选择符。（3）图片压缩。（4）代码压缩、去注释和多余代码。 三、其他优化 CDN Gzip压缩 多域名]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试经历</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈Object.create()]]></title>
    <url>%2Fjavascript%E8%BF%9B%E9%98%B6%2F2019%2F04%2F08%2F%E8%B0%88%E8%B0%88Object-create.html</url>
    <content type="text"><![CDATA[Object.create()一、首先放MDN上的定义： Object.create()方法创建一个新对象，使用现有的对象来提供新建对象的__proto__ 语法： 12&gt; Object.create(proto, [propertiesObject])&gt; 参数： proto ：新创建对象的原型对象。 propertiesObject 可选。如果没有指定为undefined ，则是要添加到新创建对象的可枚举属性（即其自身定义的属性，而不是其原型链上的枚举属性）对象的属性描述符以及相应的属性名称。这些属性对应的Object.defineProperties()的第二个参数。 返回值：一个新对象，带着指定的原型对象和属性。 例外：如果propertiesObject参数不是null或一个对象，则抛出一个TypeError异常。 二、个人理解Object.create(null)创建的是一个空对象，并且该对象上没有继承Object.prototype原型链上的属性或者方法，例如：toString(),hasOwnProperty()等方法。 三、MDN代码实践 var o; // 创建一个原型为null的空对象 o = Object.create(null); o = {} // 以字面量方式创建的空对象就相当于： o = Object.create(Object.prototype); o = Object.create(Object.prototype,{ ​ // foo会成为所创建对象的数据属性 ​ foo: { ​ writeable: true, ​ configurable: true, value: &apos;hello&apos; ​ }, ​ // bar 会成为所创建对象的访问器属性 ​ bar: { ​ configurable: false, ​ get: function() { return 10 }, ​ set: function(value) { ​ console.log(“Setting o.bar to “, value); ​ } ​ } }); function Constructor() {} o = new Constructor(); // 上面的一句就相当于： o = Object.create(Constructor.prototype); // 当然，如果在Constructor函数中有一些初始化代码，Object.create不能执行那些代码。 // 创建一个以另一个空对象为原型，且拥有一个属性p的对象 o = Object.create({}, { p: { value: 42 } }) // 省略了的属性特性默认为false，所以属性p是不可写、不可枚举、不可配置的： o.p = 24 o.p // 24 o.q = 12 for(var prop in o) { ​ console.log(prop) } // “q” delete o.p // false // 创建一个可写的、可枚举的、可配置的属性p o2 = Object.create({}, { ​ p: { ​ value: 42, ​ writeable: true, ​ configurable: true ​ } }) 四、Object.create(null)的使用场景为什么很多源码作者会使用Object.create(null)来初始化一个新对象呢？这是作者的习惯，还是一个最佳实践？ 其实都不是，这并不是作者不经思考随便用的，也不是javascript编程中的最佳实践，而是需要因地制宜，具体问题具体分析。 我们进一步比较一下Object.create(null)和{}创建控对象的区别： 在chrome打印如下： 从上图可以看到，使用create创建的对象，没有任何属性，显示No properties，我们可以把它当作一个非常纯净的map来使用，我们可以自己定义hasOwnProperty、toString方法，不管是有意还是不小心，我们完全不必担心会将原型链上的同名方法覆盖掉。举个例子： //Demo1: var a= {…省略很多属性和方法…}; //如果想要检查a是否存在一个名为toString的属性，你必须像下面这样进行检查： if(Object.prototype.hasOwnProperty.call(a,’toString’)){ ​ … } //为什么不能直接用a.hasOwnProperty(‘toString’)? //因为你可能给a添加了一个自定义的hasOwnProperty //你无法使用下面这种方式来进行判断,因为原型上的toString方法是存在的： if(a.toString){} //Demo2: var a=Object.create(null) //你可以直接使用下面这种方式判断，因为存在的属性，都将定义在a上面，除非手动指定原型： if(a.toString){} 另一个使用create(null)的理由是，在我们使用for..in循环的时候会遍历对象原型链上的属性，使用create(null)就不必再对属性进行检查了，当然，我们也可以直接使用Object.keys[]。 五、总结 你需要一个非常干净且高度可定制的对象当作数据字典的时候； 想节省hasOwnProperty带来的一丢丢性能损失并且可以偷懒少些一点代码的时候; 用Object.create(null)吧！其他时候，请用{}。]]></content>
      <categories>
        <category>javascript进阶</category>
      </categories>
      <tags>
        <tag>javascript</tag>
        <tag>object</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试主题优化]]></title>
    <url>%2Funcategorized%2F2019%2F04%2F08%2F%E6%B5%8B%E8%AF%95%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[测试发布文章]]></title>
    <url>%2Ftest%2F2019%2F04%2F08%2F%E6%B5%8B%E8%AF%95%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0.html</url>
    <content type="text"><![CDATA[新博客文章发布测试]]></content>
      <categories>
        <category>test</category>
      </categories>
      <tags>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Funcategorized%2F2019%2F02%2F12%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
